- need a way to notify miners to stop or of a new high so they won't report their new highs if it is lower than the highest from all workers. The while loop runs too tightly for the onmessage to interrupt, so I need to refactor it so every 500_000 iterationts it will schedule another loop with setTimeout(loop, 0). fixing this will also allow us to properly send the stop command and have it be obeyed because right now it isnt'.

- here's how to fix the encoding problem (zero progress as of this commit, but this is how to fix it via ChatGPT)

Your approach is an interesting one and can certainly offer performance gains by reducing string manipulations. However, the reason for the discrepancies between your process and the standard process is likely due to differences in encoding. JSON.stringify and TextEncoder handle special characters and escape sequences in particular ways.

The TextEncoder method encodes a string as a sequence of UTF-8 bytes, which includes escaping special characters. This means that it's not as simple as just swapping out bytes in the encoded sequence, because certain characters can change the overall length of the sequence. The sequence can be 1-4 bytes long per character, depending on the character. This is likely why you are seeing different hashes.

One solution to this would be to avoid characters in your nonce that result in a multi-byte sequence when UTF-8 encoded. If you stick to ASCII characters (which are represented as single bytes in UTF-8), your strategy should work, because each ASCII character will always encode to the same single byte, regardless of context. If you need a large nonce space, consider using a larger number of ASCII characters.

For example, you could use a 12 character nonce, where each character is a hexadecimal digit. This would give you a nonce space of 2^48 (the same as a 6-byte nonce) and each nonce would UTF-8 encode to exactly 12 bytes.

Here's what that might look like in code:

```javascript
let nonce = '000000000000';  // a 12-char nonce with each char being a hexadecimal digit

// ...
// Where you need to increment the nonce:

nonce = (parseInt(nonce, 16) + 1).toString(16).padStart(12, '0');
```

This approach should allow you to pre-encode the JSON string, increment the nonce, and hash the bytes while still following the standard process, thus avoiding any memory leaks or performance issues with JSON.stringify or TextEncoder.